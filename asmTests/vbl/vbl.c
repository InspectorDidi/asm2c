// Generated by asm2c https://github.com/frranck/asm2c

#include "vbl.h"
Memory m = {
{0,0,0,0,0,21,0,0,42,0,0,63,9,0,0,9}, //pal_jeu
{0,21,9,0,42,9,0,63,18,0,0,18,0,21,18,0}, //dummy1
{42,18,0,63,27,0,0,27,0,21,27,0,42,27,0,63}, //dummy2
{36,0,0,36,0,21,36,0,42,36,0,63,45,0,0,45}, //dummy3
{0,21,45,0,42,45,0,63,54,0,0,54,0,21,54,0}, //dummy4
{42,54,0,63,63,0,0,63,0,21,63,0,42,63,0,63}, //dummy5
{0,9,0,0,9,21,0,9,42,0,9,63,9,9,0,9}, //dummy6
{9,21,9,9,42,9,9,63,18,9,0,18,9,21,18,9}, //dummy7
{42,18,9,63,27,9,0,27,9,21,27,9,42,27,9,63}, //dummy8
{36,9,0,36,9,21,36,9,42,36,9,63,45,9,0,45}, //dummy9
{9,21,45,9,42,45,9,63,54,9,0,54,9,21,54,9}, //dummy10
{42,54,9,63,63,9,0,63,9,21,63,9,42,63,9,63}, //dummy11
{0,18,0,0,18,21,0,18,42,0,18,63,9,18,0,9}, //dummy12
{18,21,9,18,42,9,18,63,18,18,0,18,18,21,18,18}, //dummy13
{42,18,18,63,27,18,0,27,18,21,27,18,42,27,18,63}, //dummy14
{36,18,0,36,18,21,36,18,42,36,18,63,45,18,0,45}, //dummy15
{18,21,45,18,42,45,18,63,54,18,0,54,18,21,54,18}, //dummy16
{42,54,18,63,63,18,0,63,18,21,63,18,42,63,18,63}, //dummy17
{0,27,0,0,27,21,0,27,42,0,27,63,9,27,0,9}, //dummy18
{27,21,9,27,42,9,27,63,18,27,0,18,27,21,18,27}, //dummy19
{42,18,27,63,27,27,0,27,27,21,27,27,42,27,27,63}, //dummy20
{36,27,0,36,27,21,36,27,42,36,27,63,45,27,0,45}, //dummy21
{27,21,45,27,42,45,27,63,54,27,0,54,27,21,54,27}, //dummy22
{42,54,27,63,63,27,0,63,27,21,63,27,42,63,27,63}, //dummy23
{0,36,0,0,36,21,0,36,42,0,36,63,9,36,0,9}, //dummy24
{36,21,9,36,42,9,36,63,18,36,0,18,36,21,18,36}, //dummy25
{42,18,36,63,27,36,0,27,36,21,27,36,42,27,36,63}, //dummy26
{36,36,0,36,36,21,36,36,42,36,36,63,45,36,0,45}, //dummy27
{36,21,45,36,42,45,36,63,54,36,0,54,36,21,54,36}, //dummy28
{42,54,36,63,63,36,0,63,36,21,63,36,42,63,36,63}, //dummy29
{0,45,0,0,45,21,0,45,42,0,45,63,9,45,0,9}, //dummy30
{45,21,9,45,42,9,45,63,18,45,0,18,45,21,18,45}, //dummy31
{42,18,45,63,27,45,0,27,45,21,27,45,42,27,45,63}, //dummy32
{36,45,0,36,45,21,36,45,42,36,45,63,45,45,0,45}, //dummy33
{45,21,45,45,42,45,45,63,54,45,0,54,45,21,54,45}, //dummy34
{42,54,45,63,63,45,0,63,45,21,63,45,42,63,45,63}, //dummy35
{0,54,0,0,54,21,0,54,42,0,54,63,9,54,0,9}, //dummy36
{54,21,9,54,42,9,54,63,18,54,0,18,54,21,18,54}, //dummy37
{42,18,54,63,27,54,0,27,54,21,27,54,42,27,54,63}, //dummy38
{36,54,0,36,54,21,36,54,42,36,54,63,45,54,0,45}, //dummy39
{54,21,45,54,42,45,54,63,54,54,0,54,54,21,54,54}, //dummy40
{42,54,54,63,63,54,0,63,54,21,63,54,42,63,54,63}, //dummy41
{0,63,0,0,63,21,0,63,42,0,63,63,9,63,0,9}, //dummy42
{63,21,9,63,42,9,63,63,18,63,0,18,63,21,18,63}, //dummy43
{42,18,63,63,27,63,0,27,63,21,27,63,42,27,63,63}, //dummy44
{36,63,0,36,63,21,36,63,42,36,63,63,45,63,0,45}, //dummy45
{63,21,45,63,42,45,63,63,54,63,0,54,63,21,54,63}, //dummy46
{42,54,63,63,63,63,0,63,63,21,63,63,42,63,63,63}, //dummy47
{0}, //dummy48
0,0,0,0,0,0,0,0,0,0,0,0,0,0, // registers
0,0,0,0,0,0, //flags
0, //exitCode
{0}, //vgaPalette
0,{0},1,{0},0,{0},{0},{0},{0}, NULL};

int program() {
jmp_buf jmpbuffer;
void * dest;
void * src;
#ifdef TEST
dest=NULL;src=NULL; //to avoid a warning.
#endif
if (m.executionFinished) goto moveToBackGround;
if (m.jumpToBackGround) {
m.jumpToBackGround = 0;
RET;
}
R(MOV(16,READDW(eax),16,(dw)19));
R(INT(16));
CALL(affpal);
R(MOV(32,READDD(ebx),32,(dd)40960));
R(MOV(16,READDW(eax),16,(dw)2));
R(INT(49));
R(MOV(16,READDW(es),16,(dw)READDW(eax)));
R(XOR(32,READDD(edi),32,(dd)READDD(edi)));
R(MOV(32,READDD(eax),32,(dd)2007695104));
R(MOV(32,READDD(ecx),32,(dd)((320*200)/4)));
R(REP_STOSD);
R(MOV(32,*((dd *) realAddress(((20*320)+160), es)),32,(dd)2007695104));
R(MOV(32,*((dd *) realAddress(0, es)),32,(dd)2007695104));
R(MOV(16,READDW(edx),16,(dw)986));
arobasevbl12:
IN(READDBl(eax),READDW(edx));
R(TEST(8,READDBl(eax),8,(db)8));
R(JNE(arobasevbl12));
arobasevbl22:
IN(READDBl(eax),READDW(edx));
R(TEST(8,READDBl(eax),8,(db)8));
R(JE(arobasevbl22));
R(MOV(16,READDW(edx),16,(dw)968));
R(MOV(8,READDBl(eax),8,(db)0));
OUT(READDW(edx),READDBl(eax));
R(MOV(32,READDD(ecx),32,(dd)60));
dffd:
R(MOV(16,READDW(edx),16,(dw)986));
arobasevbl1:
IN(READDBl(eax),READDW(edx));
R(TEST(8,READDBl(eax),8,(db)8));
R(JNE(arobasevbl1));
arobasevbl2:
IN(READDBl(eax),READDW(edx));
R(TEST(8,READDBl(eax),8,(db)8));
R(JE(arobasevbl2));
R(LOOP(dffd));
R(MOV(16,READDW(eax),16,(dw)3));
R(INT(16));
R(MOV(32,READDD(edi),32,(dd)1));
R(MOV(32,READDD(esi),32,(dd)2));
R(XOR(32,READDD(eax),32,(dd)READDD(eax)));
R(JMP(exitlabel));
failure:
R(MOV(8,READDBl(eax),8,(db)1));
exitlabel:
R(MOV(8,READDBh(eax),8,(db)76));
R(INT(33));
//PROC affpal
affpal:
R(PUSHAD);
R(MOV(32,m.esi,32,(((dd)offsetof(struct Mem,pal_jeu)))));
R(MOV(16,READDW(edx),16,(dw)968));
R(XOR(8,READDBl(eax),8,(db)READDBl(eax)));
OUT(READDW(edx),READDBl(eax));
R(MOV(16,READDW(edx),16,(dw)969));
R(MOV(16,READDW(ecx),16,(dw)(256*3)));
arobasearobasesaaccvaaaax:
R(LODSB);
OUT(READDW(edx),READDBl(eax));
R(DEC(16,(READDW(ecx))));
R(JNZ(arobasearobasesaaccvaaaax));
R(POPAD);
RET;


m.executionFinished = 1;
moveToBackGround:
return (m.executionFinished == 0);
}

void stackDump() {
    printf("is_little_endian()=%d\n",is_little_endian());
    printf("sizeof(dd)=%zu\n",sizeof(dd));
    printf("sizeof(dd *)=%zu\n",sizeof(dd *));
    printf("sizeof(dw)=%zu\n",sizeof(dw));
    printf("sizeof(db)=%zu\n",sizeof(db));
    printf("sizeof(mem)=%zu\n",sizeof(m));
 //   printf("sizeof(mem)=%zu\n", offsetof(struct Mem,heapPointer)-offsetof(struct Mem,winhdle));
//    printf("sizeof(dataSeg)=%x\n", (dd) (offsetof(struct Mem,enddata)-offsetof(struct Mem,beginningdata)));
    printf("eax: %x\n",m.eax);
    hexDump(&m.eax,sizeof(dd));
    printf("ebx: %x\n",m.ebx);
    printf("ecx: %x\n",m.ecx);
    printf("edx: %x\n",m.edx);
    printf("ebp: %x\n",m.ebp);
    printf("cs: %d -> %p\n",m.cs,(void *) realAddress(0,cs));
    printf("ds: %d -> %p\n",m.ds,(void *) realAddress(0,ds));
    printf("esi: %x\n",m.esi);
    printf("ds:esi %p\n",(void *) realAddress(m.esi,ds));
    printf("es: %d -> %p\n",m.es,(void *) realAddress(0,es));
    hexDump(&m.es,sizeof(dd));
    printf("edi: %x\n",m.edi);
    printf("es:edi %p\n",(void *) realAddress(m.edi,es));
    hexDump((void *) realAddress(m.edi,es),50);
    printf("fs: %d -> %p\n",m.fs,(void *) realAddress(0,fs));
    printf("gs: %d -> %p\n",m.gs,(void *) realAddress(0,gs));
    printf("adress heap: %p\n",(void *) &m.heap);
    printf("adress vgaRam: %p\n",(void *) &m.vgaRam);
    printf("first pixels vgaRam: %x\n",*m.vgaRam);
    printf("flags: ZF = %d\n",m.ZF);
    printf("top stack=%d\n",m.stackPointer);
}

// thanks to paxdiablo http://stackoverflow.com/users/14860/paxdiablo for the hexDump function
void hexDump (void *addr, int len) {
    int i;
    unsigned char buff[17];
    unsigned char *pc = (unsigned char*)addr;

    printf ("hexDump %p:\n", addr);
    
    if (len == 0) {
        printf("  ZERO LENGTH\n");
        return;
    }
    if (len < 0) {
        printf("  NEGATIVE LENGTH: %i\n",len);
        return;
    }
    
    // Process every byte in the data.
    for (i = 0; i < len; i++) {
        // Multiple of 16 means new line (with line offset).
        
        if ((i % 16) == 0) {
            // Just don't print ASCII for the zeroth line.
            if (i != 0)
                printf ("  %s\n", buff);
            
            // Output the offset.
            printf ("  %04x ", i);
        }
        
        // Now the hex code for the specific character.
        printf (" %02x", pc[i]);
        
        // And store a printable ASCII character for later.
        if ((pc[i] < 0x20) || (pc[i] > 0x7e))
            buff[i % 16] = '.';
        else
            buff[i % 16] = pc[i];
        buff[(i % 16) + 1] = '\0';
    }
    
    // Pad out last line if not exactly 16 characters.
    while ((i % 16) != 0) {
        printf ("   ");
        i++;
    }

    // And print the final ASCII bit.
    printf ("  %s\n", buff);
}

void asm2C_OUT(int16_t address, int data) {
    static int indexPalette = 0;
    switch(address) {
        case 0x3c8:
            indexPalette=data;
            //printf("reset indexPalette to %d\n",indexPalette);
            break;
        case 0x3c9:
            if (indexPalette<768) {
               // printf("m.vgaPalette %d -> %d\n",indexPalette,data);
                m.vgaPalette[indexPalette]=data;
                indexPalette++;
            } else {
                printf("Error: indexPalette>767 %d\n",indexPalette);
            }
            break;
        default:
            printf("unknown OUT %d,%d\n",address, data);
    }
}

int8_t asm2C_IN(int16_t address) {
    static _Bool vblTick = 1;
    switch(address) {
        case 0x3DA:
            if (vblTick) {
                vblTick = 0;
                return 0;
            } else {
                vblTick = 1;
                m.jumpToBackGround = 1;
                return 8;
            }
            break;
        default:
            printf("Unknown IN %d\n",address);
            return 0;
    }
}

void asm2C_INT(int a) {
    static FILE * file;
    db ah=READDBh(eax);
    db al=READDBl(eax);
    dw ax=READDW(eax);
    dw bx=READDW(ebx);
    dw cx=READDW(ecx);
    dw dx=READDW(edx);
    m.CF = 0;
    switch(a) {
        case 0x10:
        {
            switch(ax)
            {
                case 0x03: {
                    printf("Switch to text mode\n");
                    return;
                }
                case 0x13: {
                    printf("Switch to VGA\n");
                    return;
                }
            }
            break;
        }
        case 0x21:
            switch(ah)
        {
            case 0x9:
            {
                char * s=(char *) realAddress(m.edx,ds);
                for (int i=0;s[i]!='$';i++) {
                    printf("%c", s[i]);
                }
                return;
            }
            case 0x2c:
            {
                //MOV(8,8,READDBh(edx),(db)2);
                // TOFIX
                m.edx=0x200;
                return;
            }
            case 0x3d:
            {
                char fileName[1000];
                if (m.path!=NULL) {
                    sprintf(fileName,"%s/%s",m.path,(const char *) realAddress(m.edx, ds));
                } else {
                    sprintf(fileName,"%s",(const char *) realAddress(m.edx, ds));
                }
                file=fopen(fileName, "rb"); //TOFIX, multiple files support
                printf("Opening file %s -> %p\n",fileName,(void *) file);
                if (file!=NULL) {
                    m.eax=1; //TOFIX
                } else {
                    m.CF = 1;
                    printf("Error opening file %s\n",fileName);
                }
                /*
                // [Index]AH = 3Dh - "OPEN" - OPEN EXISTING FILE
            Entry:

                AL = access and sharing modes
            DS:DX -> ASCIZ filename
            Return:

                CF clear if successful, AX = file handle
                    CF set on error AX = error code (01h,02h,03h,04h,05h,0Ch,56h)
                    */
                // TODO
                return;
            }
            case 0x3e:
            {
              // bx: file handle to close
              //TOFIX
              printf("Closing file. bx:%d\n",bx);
              if (fclose(file))  {
                    m.CF = 1;
                      perror("Error");
                      printf("Error closing file ? bx:%d %p\n",bx,(void *) file);
                }

                file=NULL;
              return;
            }
            case 0x3f:
            {
                /*
                [Index]AH = 3Fh - "READ" - READ FROM FILE OR DEVICE

            Entry:

                BX = file handle
                CX = number of bytes to read
            DS:DX -> buffer for data
                Return:

                CF clear if successful - AX = number of bytes actually read (0 if at EOF before call)
                    CF set on error AX = error code (05h,06h)
                    */
                //char grosbuff[100000];
                void * buffer=(db *) realAddress(m.edx, ds);
                //buffer=grosbuff;
                printf("Reading ecx=%d cx=%d eds=%x edx=%x -> %p file: %p\n",m.ecx,cx,m.ds,m.edx,buffer,(void *)  file);

                if (feof(file)) {
                    printf("feof(file)\n");
                  m.eax=0;
                } else {
                    size_t r=fread (buffer,1,cx,file);

//                  size_t r=fread (buffer,1,cx,file);
                  if (r!=cx) {
                      perror("Error");
                      printf("r!=cx cx:%d R:%zu \n",cx,r);
                    if(!feof(file)) {
                      printf("Error reading ? %d %zu %p\n",cx,r,(void *) file);
                      m.CF = 1;
                    }
                  } else {
                      printf("Reading OK %p\n",(void *) file);
                  }
                  m.eax=r;
                }
                /*
                if (ax!=cx) {
                    printf("Error reading ? %d %d\n",ax,cx);
                    m.CF = 1;

                }
                 */
                return;
            }
                // [Index]AH=42h - "LSEEK" - SET CURRENT FILE POSITION
            case 0x42:
            {
                /*

                 AH=42h - "LSEEK" - SET CURRENT FILE POSITION

                 Entry:

                 AL = origin of move 00h start of file 01h current file position 02h end of file
                 BX = file handle
                 CX:DX = offset from origin of new file position

                 */
                int seek = 0;
                switch(ah) {
                    case 0x0:
                        seek = SEEK_SET;
                        break;
                    case 0x1:
                        seek = SEEK_CUR;
                        break;
                    case 0x2:
                        seek = SEEK_END;
                        break;
                }
                long int offset=(cx<<16)+dx;
                printf("Seeking to offset %ld %d\n",offset,seek);
                if (fseek(file,offset,seek)!=0) {
                    printf("Error seeking\n");
                }
                return;
            }

            case 0x4c:
            {
                stackDump();
                m.jumpToBackGround = 1;
                m.executionFinished = 1;
                m.exitCode = al;
                return;
            }
            default:
                break;
        }
        case 0x31:
            switch(ax)
        {
            case 0x0:
            {
                /*
                ;2.0 - Function 0000h - Allocate Descriptors:
                ;--------------------------------------------
                ;  Allocates one or more descriptors in the client's descriptor table. The
                ;descriptor(s) allocated must be initialized by the application with other
                ;function calls.
                ;In:
                ;  AX     = 0000h
                ;  CX     = number of descriptors to allocate
                ;Out:
                ;  if successful:
                ;    carry flag clear
                ;    AX     = base selector
                 */
                printf("Function 0000h - Allocate %d Descriptors\n",cx);
                if (m.selectorsPointer+cx>=NB_SELECTORS) {
                    m.CF = 1;
                    printf("Not enough free selectors (increase NB_SELECTORS)\n");
                    return;
                } else {
                    m.eax = m.selectorsPointer;
                    m.selectorsPointer+=cx;
                    printf("Return %x\n",m.eax);
                }
                return;
            }
            case 0x02:
            {
                /*
                This function Converts a real mode segment into a protected mode descriptor.
                 BX =    real mode segment
                 Out:
                 if successful:
                 carry flag clear
                 AX =  selector
                 if failed:
                 carry flag set
                */
                printf("Function 0002h - Converts a real mode segment into a protected mode descriptor real mode segment: %d\n",m.ebx);
                if (m.selectorsPointer+1>=NB_SELECTORS) {
                    m.CF = 1;
                    printf("Not enough free selectors (increase NB_SELECTORS)\n");
                    return;
                }
                // TOFIX ?
                // always return vga adress.
                m.selectors[m.selectorsPointer]=offsetof(struct Mem,vgaRam); // bx;
                m.eax=m.selectorsPointer;
                printf("Returns new selector: eax: %d\n",m.eax);
                m.selectorsPointer++;

                // Multiple calls for the same real mode segment return the same selector. The returned descriptor should never be modified or freed. <- TOFIX
                return;
            }
                /*
                ;2.5 - Function 0007h - Set Segment Base Address:
                ; Sets the 32bit linear base address field in the descriptor for the specified
                ; segment.
                ; In:   AX     = 0007h
                ; BX     = selector
                ;  CX:DX  = 32bit linear base address of segment
                */
            case 0x07:
            {
                printf("Function 0007h - Set Segment Base Address: ebx: %x, edx:%x ecx:%x\n",m.ebx,m.edx,m.ecx);
                if (bx>m.selectorsPointer) {
                    m.CF = 1;
                    printf("Error: selector number doesnt exist\n");
                    return;
                }
                m.selectors[bx]=(READDW(edx)&0xffff)+(READDW(ecx)<<16);
                printf("Address for selector %d: %x\n",bx,m.selectors[bx]);
                return;
            }
            case 0x08:
            {
                /*
                ;2.6 - Function 0008h - Set Segment Limit:
                ;-----------------------------------------
                ;  Sets the limit field in the descriptor for the specified segment.
                ;  In:
                ;  AX     = 0008h
                ;  BX     = selector
                ;  CX:DX  = 32bit segment limit
                ;  Out:
                ;  if successful:
                ;    carry flag clear
                ;  if failed:
                ;    carry flag set
                 */

                // To implement...
                printf("Function 0008h - Set Segment Limit for selector %d (Ignored)\n",bx);
                return;
            }
            case 0x501:
            {
                /*
                ;2.29 - Function 0501h - Allocate Memory Block:
                ;In:  AX     = 0501h
                ;  BX:CX  = size of block in bytes (must be non-zero)
                ;Out: if successful:
                ;    carry flag clear
                ;    BX:CX  = linear address of allocated memory block
                ;    SI:DI  = memory block handle (used to resize and free block)
                */
                int32_t nbBlocks=(bx<<16)+cx;
                printf("Function 0501h - Allocate Memory Block: %d bytes\n",nbBlocks);

                if (m.heapPointer+nbBlocks>=HEAP_SIZE) {
                    m.CF = 1;
                    printf("Not enough memory (increase HEAP_SIZE)\n");
                    return;
                } else {
                    dd a=offsetof(struct Mem,heap)+m.heapPointer;
                    m.heapPointer+=nbBlocks;
                    {
                        dd n=offsetof(struct Mem,heap)+m.heapPointer;
                        printf("New top of heap: %x\n",n);
                    }
                    m.ecx=a & 0xFFFF;
                    m.ebx=a >> 16;
                    m.edi=0; // TOFIX
                    m.esi=0; // TOFIX
                    printf("Return %x ebx:ecx %x:%x\n",a,m.ebx,m.ecx);
                    return;
                }
                break;
            }
            case 0x205:{
                /*
                 fo implement
                 ;2.18 - Function 0204h - Get Protected Mode Interrupt Vector:
                 ;------------------------------------------------------------
                 ;
                 ;  Returns the address of the current protected mode interrupt handler for the
                 ;specified interrupt.
                 ;
                 ;In:
                 ;  AX     = 0204h
                 ;  BL     = interrupt number
                 ;
                 ;Out:
                 ;  always successful:
                 ;    carry flag clear
                 ;    CX:EDX = selector:offset of protected mode interrupt handler

                 ;  AX     = 0204h
                 ;  BL     = interrupt number
                 ;
                 ;Out:
                 ;  always successful:
                 ;    carry flag clear
                 ;    CX:EDX = selector:offset of protected mode interrupt handler
                 */

                return;
            }
            default:
                break;
        }
            break;

        default:
            break;
    }
    m.CF = 1;
    printf("Error DOSInt 0x%x ah:0x%x al:0x%x: not supported.\n",a,ah,al);
}

#ifdef TEST
int main() {
stackDump();while (program()) { }
return m.exitCode;
}
#endif


